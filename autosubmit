#!/bin/bash

scriptName=$(basename $0)
sleepTime=10


function print_usage {
    echo "Usage: $scriptName <command> [command-args]"
    echo ""
    echo "Commands:"
    echo "  submit"
    echo "  kill"
    echo "  update" 
    echo "  show"
    echo "  -r <runs> -q <queue type> <job script> <validation file> <validation string>"    
}

function print_message {
    echo -e "$1"
}

function print_error {
    print_message "$1"
    exit 1
}

function write_config_file {
    (echo jobSubmitScript=\""${jobSubmitScript}"\"
    echo jobCheckFile=\""${jobCheckFile}"\"
    echo jobCheckString=\""${jobCheckString}"\"
    echo QUEUE=\""${QUEUE}"\") > ${autoSubmitConfig}
}

function pbs_submit {
    
    local _id=$(qsub "${jobSubmitScript}")
    echo ${_id%%.*}
}

function pbs_kill {
    qdel $(get_jobid)
    return $?
}

function lsf_submit {
    local _id=$( ${lsfSubmitFile} )
    echo $_id    
}

function lsf_kill {
    bkill $(get_jobid)
    return $?
}

function create_lsf_submit_script {
    (echo '#!/bin/bash'
     echo "id=\$( bsub < ${jobSubmitScript} )"
     echo "id=\$(echo \$id | cut -f2 -d ' ' | sed -i 's/[^0-9]//g' \)"
     echo "\$id" ) > ${lsfSubmitScript}
}

function append_status_update {

    (echo '#ADDED BY AUTOSUBMIT - DO NOT REMOVE'
    echo 'autosubmit update -s 0') >> ${jobSubmitScript}
}

function remove_status_update {
    
    local n
    for n in $(grep -n -w '#ADDED BY AUTOSUBMIT - DO NOT REMOVE' ${jobSubmitScript} | cut -f1 -d ':' | sort -n -r )
    do
	sed -i.tmp "$n d" ${jobSubmitScript}
    done
    for n in $(grep -n -w 'autosubmit update -s 0' ${jobSubmitScript} | cut -f1 -d ':' | sort -n -r )
    do
	sed -i.tmp "$n d" ${jobSubmitScript}
    done

}

######################################################################
# CLEANUP FUNCTIONS                                                  #
######################################################################
function cleanup_on_error {
    rm -f ${statusFile}
    remove_status_update
}

function cleanup_on_complete {
    rm -rf $autoSubmitDir
    remove_status_update
}

function cleanup_on_kill {
    cleanup_on_error
}

function get_jobid {
    local _jobid=$(cat ${jobIDFile})
    echo $_jobid
}
function update_jobid {
    echo "$1" > ${jobIDFile}
}

function get_status {
    local _status=$(cat ${statusFile})
    echo $_status
}
function update_status {
    echo "$1" > $statusFile
}

function get_autoruns {
    local _autoruns=$(cat ${autoRunsFile})
    echo $_autoruns
}
function update_autoruns {
    echo "$1" > $autoRunsFile
}

function apply_lock {
    touch ${spinLockFile}
}
function apply_unlock {
    rm -f ${spinLockFile}
}

######################################################################
# COMMAND FUNCTIONS                                                  #
######################################################################

function autosubmit_jobs {

    # Check if things have been cleaned up from a previous Read the
    # status file in the job directory
    [ -f ${statusFile} ] &&
    print_message "Previous status file found in job directory" &&
    print_error "Check that previous jobs are complete and remove:\n${statusFile}"

    # Create autosubmit directory
    mkdir -p "${autoSubmitDir}"

    # Generate submission command
    case $QUEUE in

	"pbs"|"PBS")
	    local _submitJob=pbs_submit
	    ;;
	"lsf"|"LSF")
            local _submitJob=lsf_submit
	    create_lsf_submit_file
	    ;;
	*)
	    print_error "Specified queue not supported"
	    ;;
    esac

    # Append autosubmit status update to job script 
    append_status_update
    # Initialize autoruns file
    update_autoruns $AUTORUNS
    # Initialize the status file
    update_status 0
    # Now write configuration (global definitions)
    write_config_file

    local _jobNumber=0
    local _istop=0

    while (( $_istop == 0 ))
    do

	[ ! -d ${autoSubmitDir} ] &&
	print_message "autosubmit directory disapeared from job directory" &&
	print_error "Terminting ${scriptName} - please check for runaway jobs"

        # Read the status file in the job directory
	[ ! -f ${statusFile} ] && 
	print_message "Status file missing from job directory" &&
	print_error "Terminating ${scriptName} - submitted job with id `get_jobid` will not be stopped"

	# Perform spinlock to try to avoid race condition with status
	# updates from multiple sources
	while [[ -f ${spinLockFile} ]]
	do
	    sleep 1
	done

        # Read current job status
        local _status=$(get_status)

	if (( $_status == 0 )); then

            # Attept to start new case
            # The the number of runs left
	    local _autoRuns=$(get_autoruns)

	    [[ -z $_autoRuns ]] && print_error "Error getting autoruns"

	    if (( $_autoRuns > 0 )); then 

	        # If the validation file exists check it
		if [ -f "${jobCheckFile}" ]; then
		    
                    # For now just seeing if the whole word of the validation string is found. 
                    # This should be unique to successful runs
		    local _jobStringSearch=$(grep -w "$jobCheckString" "${jobCheckFile}")
		    if [[ -z "$_jobStringSearch"  ]]; then

		        # Job check string not found
		        # Clean up and exit
			cleanup_on_error
			print_message "Previous job not completed correctly - terminating ${scriptName}!"
			print_error "Remove ${jobCheckFile} and resubmit"

		    fi

		else
		    
		    print_message "${jobCheckFile} not found in job directory - assuming initial submission"

		fi

                # Update the job number and remaining runs
		local _jobNumber=$(( _jobNumber + 1 ))

		print_message "Submitting job $_jobNumber"

		_autoRuns=$(( _autoRuns - 1 ))
		update_autoruns $_autoRuns

		update_status 1

		local _jobID=$( $_submitJob )
		update_jobid $_jobID

	    else

	        # Cleanup
		cleanup_on_complete
		print_message "All jobs completed"
		exit 0

	    fi

	elif (( $_status == 2 )); then

	    # Received kill signal
	    cleanup_on_kill
	    print_message "Received kill signal - exiting"
	    exit 0

	fi

        # Take a power nap
	sleep ${sleepTime}

    done

}

function kill_jobs {

    [ ! -d ${autoSubmitDir} ] &&
    print_message "autosubmit directory disapeared from job directory" &&
    print_error "Terminting ${scriptName} - please check for runaway jobs"

    # Read the status file in the job directory
    [ ! -f ${statusFile} ] && 
    print_message "Status file missing from job directory"

    # Get the global definitions
    source ${autoSubmitConfig}
    
    # Generate submission command
    case $QUEUE in

	"pbs"|"PBS")
	    local _killJob=pbs_kill
	    ;;
	"lsf"|"LSF")
            local _killJob=lsf_kill
	    ;;
	*)
	    print_error "Specified queue not supported"
	    ;;
    esac

    # Go ahead and apply the lock
    apply_lock

    # Update autoruns to 0
    update_autoruns 0

    # Kill running job
    $_killJob $(get_jobid) && print_message "Stopped submitted job $(get_jobid)"

    update_status 2

    # Now unlock 
    apply_unlock

    exit 0

}

######################################################################
# Initialize global variables
######################################################################
RUNS=0
QUEUE="pbs"

jobSubmitScript="<null>"
jobCheckFile="<null>"
jobCheckString="<null>"

# job directory is assigned to the current one
#jobDir=$(pwd)
autoSubmitDir=".autosubmit"

# Set autoruns and status files, etc
autoRunsFile="${autoSubmitDir}/autoruns"
statusFile="${autoSubmitDir}/status"
jobIDFile="${autoSubmitDir}/jobid"
autoSubmitConfig="${autoSubmitDir}/config"

spinLockFile="${autoSubmitDir}/lock"
lsfSubmitScript="${autoSubmitDir}/lsfsubmit.sh"

NARGS=$#
CMD="$1"
# Check arguments
(( $NARGS == 0 )) && print_usage

case $CMD in

    "submit")

	shift
	
	for (( i=0; i<2; i++ ))
	do
	    arg="$1"
	    case "$arg" in
		
		"-r")
		    shift
		    AUTORUNS="$1"
		    ;;
		"-q")
		    shift
		    QUEUE="$1"
		    ;;
		*)
		    print_error "submit arguments specified incorrectly (see '${scriptName} help')"
		    ;;
	    esac

	    shift

	done
	
	# Check remaining number of arguments
	(( $# != 3 )) && print_error "submit arguments specified incorrectly (see '${scriptName} help')"
	
	jobSubmitScript="$1"
	jobCheckFile="$2"
	jobCheckString="$3"

	autosubmit_jobs
	;;

    "kill")
	kill_jobs
	;;
    "update")

	shift
	
	arg="$1"
	case "$arg" in
		
	    "-r")
		shift
		update_autoruns "$1"
		;;
	    "-s")
		shift
		update_status "$1"
		;;
	    *)
		print_error "update arguments specified incorrectly (see '${scriptName} help')"
		;;
	esac

	exit 0
	;;

    "show")

	shift
	
	arg="$1"
	case "$arg" in
		
	    "-r")
		get_autoruns 
		;;
	    "-j")
       		get_jobid
		;;

	    *)
		print_error "show arguments specified incorrectly (see '${scriptName} help')"
		;;
	esac

	exit 0

	;;

    "help"|"-h")
	print_usage
	;;
esac	    

exit 0
