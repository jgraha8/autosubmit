#!/bin/bash

scriptName=$(basename $0)
sleepTime=10


function print_usage {
    echo "Usage: $scriptName <command> [command-args]"
    echo "Commands:"
    echo "  submit -r <runs> -q <queue type> <job script> <validation file> <validation string>"
    echo " "
    echo "    Submit jobs and setup automatic resubmission"
    echo "    -r <runs>               Number of jobs to run"
    echo "    -q <queue type>         Type of queue that jobs will be submitted to. Supported ones"
    echo "                            PBS (or pbs) and LSF (or lsf)"
    echo "    <job script>            Job script to be sent to queue"
    echo "    <validation file>       File that contains a message upon successful completion of the job"
    echo "    <valdiation string>     String or message that should be contained in the"
    echo "                            <validation file> upon successfull completion of the job"
    echo " "
    echo "  kill                      Kill current submitted job and all subsequent submissions"
    echo " "
    echo "  update -r <runs>"
    echo " "
    echo "    Update information regarding current series of jobs" 
    echo "    -r <runs>               Remaining number of runs to resubmit"
    echo " "
    echo "  show  { -r | -j }"
    echo " "
    echo "    Show information regarding current series of jobs"
    echo "    -r                      See number of remaining jobs to be resubmitted"
    echo "    -j                      Get the current job ID that is queued/running"
}

function print_message {
    echo -e "$1"
}

function print_error {
    print_message "$1"
    exit 1
}

function write_config_file {
    (echo jobSubmitScript=\""${jobSubmitScript}"\"
    echo jobCheckFile=\""${jobCheckFile}"\"
    echo jobCheckString=\""${jobCheckString}"\"
    echo QUEUE=\""${QUEUE}"\") > ${autoSubmitConfig}
}

#######################################################################
# QUEUE FUNCTIONS                                                     #
#######################################################################
function pbs_submit {
    
    local _id=$(qsub "${jobSubmitScript}")
    local _retval=$?
    _id=${_id%%.*}
    (( $_retval != 0 )) && _id=-1
    echo $_id
}

function pbs_kill {
    qdel $(get_jobid)
    return $?
}

function lsf_submit {
    local _id=$( ${lsfSubmitScript} )
    local _retval=$(cat "${lsfSubmitScript}.exit")
    rm -f "${lsfSubmitScript}.exit"
    (( $_retval != 0 )) && _id=-1
    echo $_id
}

function lsf_kill {
    bkill $(get_jobid)
    return $?
}

function create_lsf_submit_script {
    (echo '#!/bin/bash'
     echo "id=\$( bsub < ${jobSubmitScript} )"
     echo "echo \$? > ${lsfSubmitScript}.exit"
     echo "echo \$id | cut -f2 -d ' '" > ${lsfSubmitScript}.id
     echo "sed 's/[^0-9]//g' ${lsfSubmitScript}.id"
     echo "rm -f ${lsfSubmitScript}.id") > ${lsfSubmitScript}
    chmod +x ${lsfSubmitScript}
}

#######################################################################
# JOB SUBMISSION SCRIPT MODS                                          #
#######################################################################
function append_status_update {

    (echo '#ADDED BY AUTOSUBMIT - DO NOT REMOVE'
    echo 'autosubmit update -s 0') >> ${jobSubmitScript}
}

function remove_status_update {
    
    local n
    for n in $(grep -n -w '#ADDED BY AUTOSUBMIT - DO NOT REMOVE' ${jobSubmitScript} | cut -f1 -d ':' | sort -n -r )
    do
	sed -i "$n d" ${jobSubmitScript}
    done
    for n in $(grep -n -w 'autosubmit update -s 0' ${jobSubmitScript} | cut -f1 -d ':' | sort -n -r )
    do
	sed -i "$n d" ${jobSubmitScript}
    done

}

######################################################################
# CLEANUP FUNCTIONS                                                  #
######################################################################
function cleanup_on_error {
    rm -f ${statusFile}
    remove_status_update
    exit_autosubmit_jobs
}

function cleanup_on_complete {
    rm -rf $autoSubmitDir
    remove_status_update
    exit_autosubmit_jobs
}

function cleanup_on_kill {
    cleanup_on_error
}

function get_jobid {
    local _jobid=$(cat ${jobIDFile})
    echo $_jobid
}
function update_jobid {
    echo "$1" > ${jobIDFile}
}

function get_status {
    local _status=$(cat ${statusFile})
    echo $_status
}
function update_status {
    echo "$1" > $statusFile
}

function get_autoruns {
    local _autoruns=$(cat ${autoRunsFile})
    echo $_autoruns
}
function update_autoruns {

    echo "$1" > $autoRunsFile
}

function apply_lock {
    touch "$1"
}

function apply_unlock {
    rm -f "$1"
}

function enter_spin_lock {
    while [[ -f "$1" ]]
    do
	sleep 0.1
    done
}

function enter_autosubmit_jobs {
    touch ${autoSubmitJobsFile}
}
function exit_autosubmit_jobs {
    rm -f ${autoSubmitJobsFile}
}
function check_autosubmit_jobs {
    [ ! -f ${autoSubmitJobsFile} ] &&
    print_error "No jobs are currently submitted - exiting"

}
######################################################################
# COMMAND FUNCTIONS                                                  #
######################################################################

function autosubmit_jobs {

    # Check if things have been cleaned up from a previous Read the
    # status file in the job directory
    [ -f ${statusFile} ] &&
    print_message "Previous status file found in job directory" &&
    print_error "Check that previous jobs are complete and remove:\n${statusFile}"

    # Create autosubmit directory
    mkdir -p "${autoSubmitDir}"

    # Let others know we are entering autosubmission
    enter_autosubmit_jobs

    # Go ahead and unlock everything since locks may remain on terminated cases
    apply_unlock ${lockFileA}
    apply_unlock ${lockFileB}

    # Generate submission command
    case $QUEUE in

	"pbs"|"PBS")
	    # Make sure all caps
	    QUEUE="PBS"
	    local _submitJob=pbs_submit
	    ;;
	"lsf"|"LSF")
	    QUEUE="LSF"
            local _submitJob=lsf_submit
	    create_lsf_submit_script
	    ;;
	*)
	    print_error "Specified queue not supported"
	    ;;
    esac

    # Append autosubmit status update to job script 
    append_status_update
    # Initialize autoruns file
    update_autoruns $AUTORUNS
    # Initialize the status file
    update_status 0
    # Now write configuration (global definitions)
    write_config_file

    local _jobNumber=0
    local _istop=0

    while (( $_istop == 0 ))
    do

	[ ! -d ${autoSubmitDir} ] &&
	cleanup_on_error &&
	print_message "autosubmit directory disapeared from job directory" &&
	print_error "Terminting ${scriptName} - please check for runaway jobs"

        # Read the status file in the job directory
	[ ! -f ${statusFile} ] && 
	cleanup_on_error && 
	print_message "Status file missing from job directory" &&
	print_error "Terminating ${scriptName} - submitted job with $QUEUE id $(get_jobid) may still be queued/running"

	# Lock others from changing external values
	apply_lock ${lockFileA}

	# Perform spinlock to try to avoid race condition with status
	# and autoruns updates from multiple sources
	# Wait till others have finished
	enter_spin_lock ${lockFileB}

        # Read current job status
        local _status=$(get_status)

	if (( $_status == 0 )); then

            # Attept to start new case
            # The the number of runs left
	    local _autoRuns=$(get_autoruns)

	    if (( $_autoRuns > 0 )); then 

	        # If the validation file exists check it
		if [ -f "${jobCheckFile}" ]; then
		    
                    # For now just seeing if the whole word of the validation string is found. 
                    # This should be unique to successful runs
		    local _jobStringSearch=$(grep -w "$jobCheckString" "${jobCheckFile}")
		    if [[ -z "$_jobStringSearch"  ]]; then

		        # Job check string not found
		        # Clean up and exit
			cleanup_on_error
			print_message "Previous job not completed correctly - terminating"
			print_error "Remove ${jobCheckFile} and resubmit"

		    fi

		else
		    
		    print_message "${jobCheckFile} not found in job directory - assuming initial submission"

		fi

                # Update the job number and remaining runs
		local _jobNumber=$(( _jobNumber + 1 ))
		_autoRuns=$(( _autoRuns - 1 ))
		AUTORUNS=$(( _jobNumber + _autoRuns ))

		update_autoruns $_autoRuns
		update_status 1

		local _jobID=$( $_submitJob )
		[[ $_jobID -eq -1 || -z $_jobID ]] && 
		cleanup_on_error &&
		print_error "Unable to start $QUEUE job"

		update_jobid $_jobID

		print_message "Submitted $QUEUE job ${_jobID} ($_jobNumber of $AUTORUNS)"
		
		# Unlock and sleep so that if others are spinning they
		# have time to apply their lock
		apply_unlock ${lockFileA} && sleep 1

	    else

	        # Cleanup
		cleanup_on_complete
		print_message "All jobs completed"
		exit 0

	    fi

	elif (( $_status == 2 )); then

	    # Received kill signal
	    cleanup_on_kill
	    print_message "Received kill signal - exiting"
	    exit 0

	else 
	
            # Unlock and sleep so that if others are spinning they
	    # have time to apply their lock
	    apply_unlock ${lockFileA} && sleep 1

	fi

        # Take a power nap
	sleep ${sleepTime}

    done

}

function kill_jobs {

    [ ! -d ${autoSubmitDir} ] &&
    print_message "autosubmit directory disapeared from job directory" &&
    print_error "Terminting ${scriptName} - please check for runaway jobs"

    # Read the status file in the job directory
    [ ! -f ${statusFile} ] && 
    print_message "Status file missing from job directory"

    # Get the global definitions
    source ${autoSubmitConfig}
    
    # Generate submission command
    case $QUEUE in

	"pbs"|"PBS")
	    local _killJob=pbs_kill
	    ;;
	"lsf"|"LSF")
            local _killJob=lsf_kill
	    ;;
	*)
	    print_error "Specified queue not supported"
	    ;;
    esac

    # Spin till released by autosubmit_jobs
    enter_spin_lock ${lockFileA}
    # Go ahead and apply the lock
    apply_lock ${lockFileB}

    # Update autoruns to 0
    update_autoruns 0

    # Kill running job
    $_killJob $(get_jobid) && print_message "Stopped submitted $QUEUE job $(get_jobid)"

    # Update to kill status
    update_status 2

    # Now unlock 
    apply_unlock ${lockFileB}

    exit 0

}

######################################################################
# Initialize global variables
######################################################################
RUNS=0
QUEUE="pbs"

jobSubmitScript="<null>"
jobCheckFile="<null>"
jobCheckString="<null>"

# job directory is assigned to the current one
#jobDir=$(pwd)
autoSubmitDir=".autosubmit"

# Set autoruns and status files, etc
autoSubmitJobsFile="${autoSubmitDir}/autosubmit_job"
autoRunsFile="${autoSubmitDir}/autoruns"
statusFile="${autoSubmitDir}/status"
jobIDFile="${autoSubmitDir}/jobid"
autoSubmitConfig="${autoSubmitDir}/config"


# Set lock files
lockFileA="${autoSubmitDir}/lock.a"
lockFileB="${autoSubmitDir}/lock.b"

#Set lsf submission script
lsfSubmitScript="${autoSubmitDir}/lsfsubmit.sh"

NARGS=$#
CMD="$1"
# Check arguments
(( $NARGS == 0 )) && print_usage

case $CMD in

    "submit")

	shift
	
	for (( i=0; i<2; i++ ))
	do
	    arg="$1"
	    case "$arg" in
		
		"-r")
		    shift
		    AUTORUNS="$1"
		    ;;
		"-q")
		    shift
		    QUEUE="$1"
		    ;;
		*)
		    print_error "submit arguments specified incorrectly (see '${scriptName} help')"
		    ;;
	    esac

	    shift

	done
	
	# Check remaining number of arguments
	(( $# != 3 )) && print_error "submit arguments specified incorrectly (see '${scriptName} help')"
	
	jobSubmitScript="$1"
	jobCheckFile="$2"
	jobCheckString="$3"

	autosubmit_jobs
	;;

    "kill")
      
        # Make sure autosubmit_jobs is actually running
	check_autosubmit_jobs
    
	kill_jobs
	;;
    "update")

	shift

        # Make sure autosubmit_jobs is actually running
	check_autosubmit_jobs

        # Spin till released by autosubmit_jobs
        enter_spin_lock ${lockFileA}
        # Go ahead and apply the lock
        apply_lock ${lockFileB}
	
	arg="$1"
	case "$arg" in
		
	    "-r")
		shift
		update_autoruns "$1"
		;;
	    "-s")
		shift
		update_status "$1"
		;;
	    *)
		apply_unlock ${lockFileB}
		print_error "update arguments specified incorrectly (see '${scriptName} help')"
		;;
	esac

	apply_unlock ${lockFileB}
	exit 0
	;;

    "show")

	shift
    
        # Make sure autosubmit_jobs is actually running
        check_autosubmit_jobs
	
	arg="$1"
	case "$arg" in
		
	    "-r")
		get_autoruns 
		;;
	    "-j")
       		get_jobid
		;;

	    *)
		print_error "show arguments specified incorrectly ( see '${scriptName} help')"
		;;
	esac

	exit 0

	;;

    "help"|"-h")
	print_usage
        ;;

     *) 
         print_usage
         ;;
esac	    

exit 0
